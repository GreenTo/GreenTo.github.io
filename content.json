{"pages":[{"title":"404","text":"","path":"404/index.html","date":"09-16","excerpt":""},{"title":"个人资料","text":"个人介绍 职业 在校学生 爱好 动漫 音乐 微信公众号 建博客随便玩玩^_^","path":"about/index.html","date":"09-16","excerpt":""},{"title":"分类","text":"","path":"categories/index.html","date":"09-16","excerpt":""},{"title":"留言板","text":"","path":"message/index.html","date":"09-18","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"09-16","excerpt":""},{"title":"标签","text":"","path":"tags/index.html","date":"09-16","excerpt":""}],"posts":[{"title":"nexus3.X的下载安装","text":"maven的仓库只有两大类：1.本地仓库 2.远程仓库，在远程仓库中又分成了3种：2.1 中央仓库 2.2 私服 2.3 其它公共库。 私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的Maven用户使用。当Maven需要下载构件的时候，它从私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，缓存在私服上之后，再为Maven的下载请求提供服务。我们还可以把一些无法从外部仓库下载到的构件上传到私服上。 Maven私服的特性： 1.节省自己的外网带宽：减少重复请求造成的外网带宽消耗 2.加速Maven构件：如果项目配置了很多外部远程仓库的时候，构建速度就会大大降低 3.部署第三方构件：有些构件无法从外部仓库获得的时候，我们可以把这些构件部署到内部仓库(私服)中，供内部maven项目使用 4.提高稳定性，增强控制：Internet不稳定的时候，maven构建也会变的不稳定，一些私服软件还提供了其他的功能 5.降低中央仓库的负荷：maven中央仓库被请求的数量是巨大的，配置私服也可以大大降低中央仓库的压力 因此我们在实际的项目中通常使用私服来间接访问中央仓库，项目通常不直接访问中央仓库而nexus就是私服，下面将介绍ｎｅｘｕｓ３．Ｘ的下载安装教程ｎｅｘｕｓ官网下载地址 http://www.sonatype.com/download-oss-sonatype １．下载．后第一层目录如下，进入ｎｅｘｕｓ目录， ２．ｎｅｘｕｓ的安装．进入ｎｅｘｕｓ的ｂｉｎ目录，输入：ｎｅｘｕｓ／ｉｎｓｔａｌｌ，即可完成注册服务． ３．将服务启动方式改为手动，手动可以减少内存的使用 ４．启动服务．有两种启动方式，第一种方式 开始 -&gt; 运行 -&gt; cmd -&gt; net start nexus启动服务 net start nexus停止服务 net stop nexus第二种进入任务管理器开启服务． ５．验证是否安装成功． 当服务启动成功后，打开浏览器，输入 http://localhost:8081/ ，即可如果出现404错误，或者打不开，可以等待30秒到一分钟，在尝试访问，即可成功","path":"2018/09/20/article4/","date":"09-20","excerpt":""},{"title":"快速排序法","text":"基本思想: 取数组的第一个位置作为基准值,小于基准值的放数组左边,大于基准值的放数组右边,递归数组两边的排序. 代码实现:第一代版本: 运行结果: 缺点:该版本只能对存储不重复数的数组进行排序,若数组含有重复数,改程序将死循环. 源码:123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Arrays;public class QuickSort &#123; public static void quickSort(int[] arr,int low,int high) &#123; int i = low; int j = high; if(low &gt;= high) &#123; return; &#125; int key = i; while(low &lt; high) &#123; while(low &lt; high &amp;&amp; arr[high] &gt; arr[key]) &#123; high--; &#125; while(low &lt; high &amp;&amp; arr[low] &lt; arr[key]) &#123; low++; &#125; if(low &lt; high) &#123; int temp = arr[high]; arr[high] = arr[low]; arr[low] = temp; &#125; &#125; if(low &lt; high) &#123; int temp = arr[key]; arr[key] = arr[low]; arr[low] = temp; &#125; quickSort(arr, key+1, j); quickSort(arr, i, key-1); &#125; public static void main(String[] args) &#123; int arr[] = &#123;1,3,2,5,66,33,22,0,55,8&#125;; QuickSort.quickSort(arr, 0, arr.length-1); System.out.println(Arrays.toString(arr)); &#125;&#125; 第二代版本: 运行结果: 该程序好处是不会漏掉任何一个数，坏处是交换次数较多，效率较低 源码:1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.Arrays;public class QuickSort2 &#123; public static void sort(int[] arr,int low,int high) &#123; if(low &gt; high) &#123; return; &#125; int i = low; int j = high; int value = arr[i]; boolean flag = true; while(i != j) &#123; if(flag) &#123; if(value &gt; arr[j]) &#123; swap(arr,i,j); flag = false; &#125;else &#123; j--; &#125; &#125;else &#123; if(value &lt; arr[i]) &#123; swap(arr,i,j); flag = true; &#125;else &#123; i++; &#125; &#125; &#125; sort(arr,low,i-1); sort(arr,i+1,high); &#125; private static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; public static void main(String[] args) &#123; int arr[] = &#123;1,3,2,5,66,33,22,0,55,8,8&#125;; QuickSort2.sort(arr, 0, arr.length-1); System.out.println(Arrays.toString(arr)); &#125;&#125;","path":"2018/09/20/article3/","date":"09-20","excerpt":""},{"title":"二分查找法","text":"原理: 首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两&gt;者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。 程序: 运行结果: 源码:1234567891011121314151617181920212223242526272829303132package primary;public class BinarySearch &#123; public int indexOfEle(int[] arr,int item) &#123; int high = arr.length-1; int low = 0; int mid = 0; while(low &lt;= high) &#123; mid = (low + high)/2; System.out.println(&quot;mid:&quot; + mid); if(item &lt; arr[mid]) &#123; high = mid-1; System.out.println(&quot;high:&quot; + high); &#125;else if(item &gt; arr[mid]) &#123; low = mid+1; System.out.println(&quot;low:&quot; + low); &#125;else &#123; return mid; &#125; &#125; return -1; &#125; public static void main(String[] args) &#123; BinarySearch bs = new BinarySearch(); int[] arr = &#123;1,3,4,5,10,20,30,40,50,66,77,88,99&#125;; int index = bs.indexOfEle(arr, 10); System.out.println(index); &#125;&#125;","path":"2018/09/20/article2/","date":"09-20","excerpt":""},{"title":"欢迎来到我的博客","text":"欢迎来到我的博客我的第一篇博客^_^,这是一个测试.","path":"2018/09/16/hello-world/","date":"09-16","excerpt":""}]}