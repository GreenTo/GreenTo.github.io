{"pages":[{"title":"404","text":"","path":"404/index.html","date":"09-16","excerpt":""},{"title":"个人资料","text":"个人介绍 职业 在校学生 爱好 动漫 音乐 微信公众号 建博客随便玩玩^_^","path":"about/index.html","date":"09-16","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"09-16","excerpt":""},{"title":"标签","text":"","path":"tags/index.html","date":"09-16","excerpt":""},{"title":"分类","text":"","path":"categories/index.html","date":"09-16","excerpt":""},{"title":"留言板","text":"","path":"message/index.html","date":"09-18","excerpt":""}],"posts":[{"title":"顺序栈的c语言实现","text":"今天教了顺序栈的原理,在实验课弄了这个简单的顺序栈. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#define MAXSIZE 100typedef int ElemType;typedef struct&#123; ElemType elem[MAXSIZE]; int top;&#125;Stack;void initStack(Stack *s)&#123; s-&gt;top = 0;&#125;int stackEmpty(Stack *s)&#123; if(s-&gt;top == 0)&#123; return 1; &#125;else&#123; return 0; &#125;&#125;int push(Stack *s,ElemType e)&#123; if(s-&gt;top == MAXSIZE) return 0; s-&gt;elem[s-&gt;top] = e; s-&gt;top++; return 1;&#125;void printElem(Stack *s)&#123; int i; printf(&quot;\\n栈内元素:&quot;); for(i = 0;i &lt; s-&gt;top;i++)&#123; printf(&quot;%d\\t&quot;,s-&gt;elem[i]); &#125;&#125;int pop(Stack *s,ElemType *e)&#123; int b; b = stackEmpty(s); if(b == 1) return 0; *e = s-&gt;elem[--s-&gt;top]; return 1;&#125;void main()&#123; int b,n; Stack s; initStack(&amp;s); b = push(&amp;s,18); printf(&quot;插栈是否成功:%d\\n&quot;,b); push(&amp;s,13); push(&amp;s,22); push(&amp;s,9); printElem(&amp;s); b = pop(&amp;s,&amp;n); printf(&quot;\\n栈顶元素:%d\\n&quot;,n);&#125;","path":"2018/10/12/article10/","date":"10-12","excerpt":""},{"title":"单链表的c语言实现","text":"前言:今天数据结构学了单链表,所以弄个简单的单链表单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。链表中的数据是以结点来表示的，每个结点的构成：元素(数据元素的映象) + 指针(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include&lt;stdlib.h&gt;typedef int ElemType;typedef struct Node&#123; ElemType data; struct Node *next;&#125;Node;Node* createNode() //使用尾插法初始化链表&#123; Node *p; //头结点 Node *h; int i,n; p = (Node*)malloc(sizeof(Node)); //为头结点分配内存空间 h = p; //保存头结点的地址 if(p == NULL) exit(1); p-&gt;next = NULL; //将头结点的指针域赋为null printf(&quot;请输入单链表的初始长度:&quot;); scanf(&quot;%d&quot;,&amp;n); for(i = 1;i &lt;= n;i++) &#123; Node *s = (Node*)malloc(sizeof(Node)); if(s == NULL) exit(1); p-&gt;next = s; //将下一个节点的地址赋给上一个节点的指针域,起前后节点连接作用 s-&gt;data = i; s-&gt;next = NULL; p = s; //保存当前的节点,将当前指针指向下一个节点 &#125; return h;&#125;int insertNode(Node *p,int i,ElemType elem)&#123; int j; Node *h,*s; h = p; //储存当前指针 for(j = 0;j &lt; i-1 &amp;&amp; h != NULL;j++) //逐个找第i-1个位置插入 h = h-&gt;next; if(j != i-1) return 0; //如果找不到插入点.返回0 s = (Node*)malloc(sizeof(Node)); s-&gt;data = elem; s-&gt;next = h-&gt;next; //将插入位置的前一个节点存储的下一个节点地址赋给新节点的指针域 h-&gt;next = s; //将新节点的地址赋给插入位置的前一个节点的指针域 return 1;&#125;Node* findNode(Node *p,ElemType elem) //按值查找节点&#123; Node *f; f = p-&gt;next; while((f != NULL) &amp;&amp; (f-&gt;data != elem)) &#123; f = f-&gt;next; &#125; return f;&#125;int deleteNode(Node *p,int i) &#123; Node *h,*d; int j; h = p; for(j = 0;j &lt; i-1;j++) &#123; h = h-&gt;next; &#125; if(j != i-1) return 0; d = h-&gt;next; //d指向将要删除的节点 h-&gt;next = d-&gt;next; //将将要删除的节点的下一个节点的地址赋给上一个节点的指针域 free(d); return 1;&#125;void main()&#123; Node *p; Node *f; int b; ElemType elem = 50; p = createNode(); b = insertNode(p,5,elem); //向第五个位置插入50 //if(b == 0) // printf(&quot;插入失败!\\n&quot;); f = findNode(p,elem); //查找储存50的这个节点 if(f-&gt;data == elem) printf(&quot;插入成功!\\n&quot;); else&#123; printf(&quot;找不到该节点,插入失败!\\n&quot;); &#125; b = deleteNode(p,5); //第五个节点存了50 if(b == 1) printf(&quot;删除成功!\\n&quot;); f = findNode(p,5,elem); if(f-&gt;data != elem) printf(&quot;删除成功!\\n&quot;); //双重保险来测试 else&#123; printf(&quot;找到了该节点,删除失败!\\n&quot;); &#125;&#125;","path":"2018/09/21/article9/","date":"09-21","excerpt":""},{"title":"顺序表的c语言实现","text":"前言:今天数据结构学了顺序表,所以弄一个简单的顺序表出来.顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元依次存储线性表中的各个元素、使得线性表中在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系，采用顺序存储结构的线性表通常称为顺序表。顺序表是将表中的结点依次存放在计算机内存中一组地址连续的存储单元中.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;#define MAX_LENGTH 10typedef int ElemType;typedef struct&#123; ElemType *elem; int length; int listsize;&#125;SeqList;int initList(SeqList *L)&#123; L-&gt;elem = (ElemType*)malloc(MAX_LENGTH * sizeof(ElemType)); //若内存空间分配失败,elem=null if(!L-&gt;elem) return 0; L-&gt;listsize = MAX_LENGTH; L-&gt;length = 0; return 1;&#125;int insertElem(SeqList *L,int i,ElemType e)&#123; int j = 0; if(i &lt; 1 || i &gt; L-&gt;length+1 || L-&gt;length == L-&gt;listsize) return 0; for(j = L-&gt;length-1;j &gt;= i-1;j--) &#123; L-&gt;elem[j+1] = L-&gt;elem[j]; &#125; L-&gt;elem[i-1] = e; L-&gt;length++; return 1;&#125;int findElem(SeqList List,ElemType e)&#123; int i; for(i = 0;i &lt; List.length;i++) &#123; if(e == List.elem[i]) return i+1; &#125; return 0;&#125;int deleteElem(SeqList *L,int i)&#123; int j; if(i &lt; 1 || i &gt; L-&gt;length) return 0; for(j = i;j &lt; L-&gt;length;j++) &#123; L-&gt;elem[j-1] = L-&gt;elem[j]; &#125; L-&gt;length--; //无法单独释放该元素,只能末位赋0.或者创建一个新数组. L-&gt;elem[j] = 0; return 1;&#125;void printElem(SeqList List)&#123; int i; for(i = 0;i &lt; List.length;i++) &#123; printf(\"%d\\t\",List.elem[i]); &#125;&#125;int main()&#123; int b,i; SeqList List; SeqList *L; L = &amp;List; initList(L); for(i = 0;i &lt; 5;i++) &#123; L-&gt;elem[i] = i; L-&gt;length++; &#125; //printf(\"%d\",b); 测试是否插入成功 printf(\"\\n--------------\\n添加前:\"); printElem(List); b = findElem(List,3); //查找3 printf(\"\\n3在第%d个位置\\n\",b); printf(\"\\n--------------\\n添加后:\"); b = insertElem(L,3,5); //在第三个位置插入5 printElem(List); b = deleteElem(L,3); //删除第三个数 printf(\"\\n--------------\\n删除后:\"); printElem(List);&#125;","path":"2018/09/21/article8/","date":"09-21","excerpt":""},{"title":"javaweb:浏览器请求到服务器端响应的简单过程","text":"学习javaweb的同学应该都有过一个混乱的时期,那时还弄不明白到底请求到响应的过程是如何进行的?web服务器是干什么的?Servlet归什么管?Servlet本质上不就是一个普通的java类吗,没有main方法是如何工作的?(文章中请求一律指HTTP请求,Servlet指HttpServlet)那么接下来就开始讲解了,这是我的一些个人认知,有不准确的请多多纠正. 要先了解整个过程,需要先明白大概.1.首先,浏览器发送http请求2.若该请求是请求静态资源(html,css等),则web server能自行处理,返回静态资源.3.若该请求是请求动态资源(jsp等),则Web Server就会交由Application Server处理,处理的结果再传给Web Server返回浏览器. 那么,你可能会问,什么是Web Server?什么是Application Server?简单来说,Web Server是可以向浏览器提供静态资源的程序,当然了,它还能将请求转发给Application Server处理.Application Server能提供动态资源,同时也具备了Web Server处理请求的能力(但没有那么专业).对了,Tomcat就是一种Application Server.顺便一提,企业级开发中,Web Server是和Application Server共同协作,分工明确的,一个提供静态资源,一个提供动态资源,这样能很好地提高处理请求的效率. 额,那么Servlet又是如何工作的呢?其实,Servlet是归Web容器管理的,Web容器管理着Servlet的整个生命周期,向Servlet提供请求和响应,调用Servlet的方法,所以Servlet类无需main方法.而Web容器是在Application Server上的.Web容器可能有点理解,其实你也可以将Tomcat当成一个Web容器. 既然Servlet是归容器管理的,那么容器又是如何处理请求的呢? 1.当浏览器发送请求,容器会根据URL找到该项目,然后从该项目读取我们编写 Servlet 中的 @WebServlet 标注或者 web.xml 配置，找到能处理该请求的 Servlet. 2.若该Servlet是第一次被访问,则创建Servlet对象servlet,调用servlet的init()方法从配置文件中获取自己的初始化参数,否则直接创建HttpServletRequest和HttpServletResponse的对象request和response. 2.容器为该servlet创建一条线程,然后将request和response对象传给这条线程. 3.容器调用servlet的service()方法,根据请求的不同调用doGet()或doPost()方法.(假设请求方法是get) 4.doGet()方法生成动态页面(其实这是JSP做的),并将结果”放入”response方法. 5.线程结束,容器把response转换成一个HTTP响应,把它传给浏览器,然后删除request和response,线程被销毁. 以上就是浏览器发起请求到服务端响应的一个简单过程,可能会有一些错误,希望你能提醒小编纠正,谢谢^_^","path":"2018/09/20/article7/","date":"09-20","excerpt":""},{"title":"MyEclipse 2017 配置Tomcat步骤","text":"网上关于MyEclipse 2017版本的信息并不多,想要了解更多细节就没办法查到,因此小编写下此篇文章供大家参考. 至于为什么这类信息较少,是因为2017版本是最新的,很少人会使用这个版本.为什么很少人会使用呢?因为最新版本随时会更新,并不稳定,实际开发中使用的开发工具一定是稳定版的,毕竟谁也不想用着用着出bug了(滑稽).但毕竟是最新版本,功能肯定比旧版本丰富强大,用于学习是很不错的. 1.下载Tomcat服务器,还没下载的可到官网下载,有两个版本,分别是安装版和非安装版.如果不想多折腾,就果断选择安装版,这是懒人专用的,小编也是此类.具体安装过程请百度,这里就不作叙述了. 2.Tomcat环境配置,若是安装版的,在安装过程中就会配置好了,前提是jdk环境变量已配置成功.非安装版的会多一些步骤,这就是我选择安装版的原因之一,其二是安装版有管理的图形界面,如下图 但非安装版也有它的好处,首先,它不需要安装(那不是废话么),所以,理论上你可以有无数个tomcat服务器,只要每个服务器的端口号不同即可.你可以在安装目录的conf目录下找到server.xml,用记事本或编辑器打开,然后修改该文件即可. 123端口号一般用到的是1到65535，其中0不使用一般的应用程序使用1024到4999用来通讯5000以后的用来用户自定义端口 3.配置tomcat服务器. 1由于小编已事先配置了tomcat,因此移除上图配置好的tomcat. 4.修改tomcat默认的工作空间.不修改的话,那部署项目到tomcat该项目就不知道去哪了(别问小编,小编也找不到去哪了). 5.最后,示范一下在tomcat部署项目的步骤","path":"2018/09/20/article6/","date":"09-20","excerpt":""},{"title":"MyEclipse 2017版本 配置工作空间的步骤","text":"相信学javaweb的朋友们都听说过MyEclipse吧,它功能比eclipse更为强大,但是它并不是免费的.虽然如此,这些却难不倒我们中国人,你懂的.本篇文章适合刚配置好MyEclipse 2017版本工作环境(指已经配置好环境变量JAVA_HOME和Path,CLASSPATH自jdk1.5后便无需配置了)的朋友看.若还没配置好jdk环境变量可以上网百度一下,网上一大堆,这里就不重复了. 1.首先打开MyEclipse找到菜单栏Window下的最后一项Preferences,搜索WorkSpaces后将默认编码为GBK改为UTF-8.确定修改后的已有工作项目(注释会乱码,只能重新写注释)和以后创建的所有项目的编码都为UTF-8.至于为什么要改为UTF-8,这是因为UTF-8为国际通用码表,工作中正常情况都使用该码表,而GBK码表是国标,是专门为方便汉字写入而定的,除了中国没有别的国家会用,因此选用UTF-8会就拥有最高的兼容性(UTF-8也称为万国表,含义就是字面意思啦). 2.MyEclipse 2017版默认的Jsp创建方式是比较占内存的,因此要修改JSP编辑器, 如果你的内存有16G,那可以无视这一建议了,本人电脑内存只有8G. 3.将JSP的默认编码改为UTF-8,这样所有工程项目文件的编码都统一了,就不用担心再出现乱码了. 4.调整代码格式.好的代码格式能令人身心愉悦. 接着便可以按自己喜欢的字体格式设置了,是不是很简单然后,你要是想要有自动提示的,可以在下图框框中加入”qwertyuiopasdfghjklzxcvbnm”,这样敲代码时就会有提示了,是不是很实用! 当然了,不同类型的代码也可以自己设置颜色,大小什么的 5.MyEclipse 2017版本的自带服务器是没什么卵用的(主要是功能不够强大),不如用自己下载的服务器.因此我们要移除它自带的服务器,可惜的是,由于本人能力有限,捣鼓了这个半天,还是无法成功移除,等我找到方法了,我会在发一篇文章的,敬请期待哈.我只能将自带服务器隐藏起来,眼不见心不烦","path":"2018/09/20/article5/","date":"09-20","excerpt":""},{"title":"nexus3.X的下载安装","text":"maven的仓库只有两大类：1.本地仓库 2.远程仓库，在远程仓库中又分成了3种：2.1 中央仓库 2.2 私服 2.3 其它公共库。 私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的Maven用户使用。当Maven需要下载构件的时候，它从私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，缓存在私服上之后，再为Maven的下载请求提供服务。我们还可以把一些无法从外部仓库下载到的构件上传到私服上。 Maven私服的特性： 1.节省自己的外网带宽：减少重复请求造成的外网带宽消耗 2.加速Maven构件：如果项目配置了很多外部远程仓库的时候，构建速度就会大大降低 3.部署第三方构件：有些构件无法从外部仓库获得的时候，我们可以把这些构件部署到内部仓库(私服)中，供内部maven项目使用 4.提高稳定性，增强控制：Internet不稳定的时候，maven构建也会变的不稳定，一些私服软件还提供了其他的功能 5.降低中央仓库的负荷：maven中央仓库被请求的数量是巨大的，配置私服也可以大大降低中央仓库的压力 因此我们在实际的项目中通常使用私服来间接访问中央仓库，项目通常不直接访问中央仓库而nexus就是私服，下面将介绍ｎｅｘｕｓ３．Ｘ的下载安装教程ｎｅｘｕｓ官网下载地址 http://www.sonatype.com/download-oss-sonatype １．下载．后第一层目录如下，进入ｎｅｘｕｓ目录， ２．ｎｅｘｕｓ的安装．进入ｎｅｘｕｓ的ｂｉｎ目录，输入：ｎｅｘｕｓ／ｉｎｓｔａｌｌ，即可完成注册服务． ３．将服务启动方式改为手动，手动可以减少内存的使用 ４．启动服务．有两种启动方式，第一种方式 开始 -&gt; 运行 -&gt; cmd -&gt; net start nexus启动服务 net start nexus停止服务 net stop nexus第二种进入任务管理器开启服务． ５．验证是否安装成功． 当服务启动成功后，打开浏览器，输入 http://localhost:8081/ ，即可如果出现404错误，或者打不开，可以等待30秒到一分钟，在尝试访问，即可成功","path":"2018/09/20/article4/","date":"09-20","excerpt":""},{"title":"快速排序法","text":"基本思想: 取数组的第一个位置作为基准值,小于基准值的放数组左边,大于基准值的放数组右边,递归数组两边的排序. 代码实现:第一代版本: 运行结果: 缺点:该版本只能对存储不重复数的数组进行排序,若数组含有重复数,改程序将死循环. 源码:123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Arrays;public class QuickSort &#123; public static void quickSort(int[] arr,int low,int high) &#123; int i = low; int j = high; if(low &gt;= high) &#123; return; &#125; int key = i; while(low &lt; high) &#123; while(low &lt; high &amp;&amp; arr[high] &gt; arr[key]) &#123; high--; &#125; while(low &lt; high &amp;&amp; arr[low] &lt; arr[key]) &#123; low++; &#125; if(low &lt; high) &#123; int temp = arr[high]; arr[high] = arr[low]; arr[low] = temp; &#125; &#125; if(low &lt; high) &#123; int temp = arr[key]; arr[key] = arr[low]; arr[low] = temp; &#125; quickSort(arr, key+1, j); quickSort(arr, i, key-1); &#125; public static void main(String[] args) &#123; int arr[] = &#123;1,3,2,5,66,33,22,0,55,8&#125;; QuickSort.quickSort(arr, 0, arr.length-1); System.out.println(Arrays.toString(arr)); &#125;&#125; 第二代版本: 运行结果: 该程序好处是不会漏掉任何一个数，坏处是交换次数较多，效率较低 源码:1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.Arrays;public class QuickSort2 &#123; public static void sort(int[] arr,int low,int high) &#123; if(low &gt; high) &#123; return; &#125; int i = low; int j = high; int value = arr[i]; boolean flag = true; while(i != j) &#123; if(flag) &#123; if(value &gt; arr[j]) &#123; swap(arr,i,j); flag = false; &#125;else &#123; j--; &#125; &#125;else &#123; if(value &lt; arr[i]) &#123; swap(arr,i,j); flag = true; &#125;else &#123; i++; &#125; &#125; &#125; sort(arr,low,i-1); sort(arr,i+1,high); &#125; private static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; public static void main(String[] args) &#123; int arr[] = &#123;1,3,2,5,66,33,22,0,55,8,8&#125;; QuickSort2.sort(arr, 0, arr.length-1); System.out.println(Arrays.toString(arr)); &#125;&#125;","path":"2018/09/20/article3/","date":"09-20","excerpt":""},{"title":"二分查找法","text":"原理: 首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两&gt;者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。 程序: 运行结果: 源码:1234567891011121314151617181920212223242526272829303132package primary;public class BinarySearch &#123; public int indexOfEle(int[] arr,int item) &#123; int high = arr.length-1; int low = 0; int mid = 0; while(low &lt;= high) &#123; mid = (low + high)/2; System.out.println(&quot;mid:&quot; + mid); if(item &lt; arr[mid]) &#123; high = mid-1; System.out.println(&quot;high:&quot; + high); &#125;else if(item &gt; arr[mid]) &#123; low = mid+1; System.out.println(&quot;low:&quot; + low); &#125;else &#123; return mid; &#125; &#125; return -1; &#125; public static void main(String[] args) &#123; BinarySearch bs = new BinarySearch(); int[] arr = &#123;1,3,4,5,10,20,30,40,50,66,77,88,99&#125;; int index = bs.indexOfEle(arr, 10); System.out.println(index); &#125;&#125;","path":"2018/09/20/article2/","date":"09-20","excerpt":""},{"title":"欢迎来到我的博客","text":"欢迎来到我的博客我的第一篇博客^_^,这是一个测试.","path":"2018/09/16/hello-world/","date":"09-16","excerpt":""}]}